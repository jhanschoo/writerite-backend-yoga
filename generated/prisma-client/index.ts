// Code generated by Prisma (prisma@1.21.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  deck: (where?: DeckWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  simpleCard: (where?: SimpleCardWhereInput) => Promise<boolean>;
  simpleUserRoomMessage: (
    where?: SimpleUserRoomMessageWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  deck: (where: DeckWhereUniqueInput) => DeckPromise;
  decks: (
    args?: {
      where?: DeckWhereInput;
      orderBy?: DeckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Deck>;
  decksConnection: (
    args?: {
      where?: DeckWhereInput;
      orderBy?: DeckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DeckConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomPromise;
  rooms: (
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Room>;
  roomsConnection: (
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RoomConnectionPromise;
  simpleCard: (where: SimpleCardWhereUniqueInput) => SimpleCardPromise;
  simpleCards: (
    args?: {
      where?: SimpleCardWhereInput;
      orderBy?: SimpleCardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SimpleCard>;
  simpleCardsConnection: (
    args?: {
      where?: SimpleCardWhereInput;
      orderBy?: SimpleCardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SimpleCardConnectionPromise;
  simpleUserRoomMessage: (
    where: SimpleUserRoomMessageWhereUniqueInput
  ) => SimpleUserRoomMessagePromise;
  simpleUserRoomMessages: (
    args?: {
      where?: SimpleUserRoomMessageWhereInput;
      orderBy?: SimpleUserRoomMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SimpleUserRoomMessage>;
  simpleUserRoomMessagesConnection: (
    args?: {
      where?: SimpleUserRoomMessageWhereInput;
      orderBy?: SimpleUserRoomMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SimpleUserRoomMessageConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDeck: (data: DeckCreateInput) => DeckPromise;
  updateDeck: (
    args: { data: DeckUpdateInput; where: DeckWhereUniqueInput }
  ) => DeckPromise;
  updateManyDecks: (
    args: { data: DeckUpdateManyMutationInput; where?: DeckWhereInput }
  ) => BatchPayloadPromise;
  upsertDeck: (
    args: {
      where: DeckWhereUniqueInput;
      create: DeckCreateInput;
      update: DeckUpdateInput;
    }
  ) => DeckPromise;
  deleteDeck: (where: DeckWhereUniqueInput) => DeckPromise;
  deleteManyDecks: (where?: DeckWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (
    args: { data: RoomUpdateInput; where: RoomWhereUniqueInput }
  ) => RoomPromise;
  updateManyRooms: (
    args: { data: RoomUpdateManyMutationInput; where?: RoomWhereInput }
  ) => BatchPayloadPromise;
  upsertRoom: (
    args: {
      where: RoomWhereUniqueInput;
      create: RoomCreateInput;
      update: RoomUpdateInput;
    }
  ) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createSimpleCard: (data: SimpleCardCreateInput) => SimpleCardPromise;
  updateSimpleCard: (
    args: { data: SimpleCardUpdateInput; where: SimpleCardWhereUniqueInput }
  ) => SimpleCardPromise;
  updateManySimpleCards: (
    args: {
      data: SimpleCardUpdateManyMutationInput;
      where?: SimpleCardWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSimpleCard: (
    args: {
      where: SimpleCardWhereUniqueInput;
      create: SimpleCardCreateInput;
      update: SimpleCardUpdateInput;
    }
  ) => SimpleCardPromise;
  deleteSimpleCard: (where: SimpleCardWhereUniqueInput) => SimpleCardPromise;
  deleteManySimpleCards: (where?: SimpleCardWhereInput) => BatchPayloadPromise;
  createSimpleUserRoomMessage: (
    data: SimpleUserRoomMessageCreateInput
  ) => SimpleUserRoomMessagePromise;
  updateSimpleUserRoomMessage: (
    args: {
      data: SimpleUserRoomMessageUpdateInput;
      where: SimpleUserRoomMessageWhereUniqueInput;
    }
  ) => SimpleUserRoomMessagePromise;
  updateManySimpleUserRoomMessages: (
    args: {
      data: SimpleUserRoomMessageUpdateManyMutationInput;
      where?: SimpleUserRoomMessageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSimpleUserRoomMessage: (
    args: {
      where: SimpleUserRoomMessageWhereUniqueInput;
      create: SimpleUserRoomMessageCreateInput;
      update: SimpleUserRoomMessageUpdateInput;
    }
  ) => SimpleUserRoomMessagePromise;
  deleteSimpleUserRoomMessage: (
    where: SimpleUserRoomMessageWhereUniqueInput
  ) => SimpleUserRoomMessagePromise;
  deleteManySimpleUserRoomMessages: (
    where?: SimpleUserRoomMessageWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  deck: (
    where?: DeckSubscriptionWhereInput
  ) => DeckSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  simpleCard: (
    where?: SimpleCardSubscriptionWhereInput
  ) => SimpleCardSubscriptionPayloadSubscription;
  simpleUserRoomMessage: (
    where?: SimpleUserRoomMessageSubscriptionWhereInput
  ) => SimpleUserRoomMessageSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DeckOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "published_ASC"
  | "published_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "passwordHash_ASC"
  | "passwordHash_DESC"
  | "googleId_ASC"
  | "googleId_DESC"
  | "facebookId_ASC"
  | "facebookId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SimpleUserRoomMessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SimpleCardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "front_ASC"
  | "front_DESC"
  | "back_ASC"
  | "back_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DeckWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DeckWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  owner?: UserWhereInput;
  cards_every?: SimpleCardWhereInput;
  cards_some?: SimpleCardWhereInput;
  cards_none?: SimpleCardWhereInput;
  published?: Boolean;
  published_not?: Boolean;
  AND?: DeckWhereInput[] | DeckWhereInput;
  OR?: DeckWhereInput[] | DeckWhereInput;
  NOT?: DeckWhereInput[] | DeckWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  passwordHash?: String;
  passwordHash_not?: String;
  passwordHash_in?: String[] | String;
  passwordHash_not_in?: String[] | String;
  passwordHash_lt?: String;
  passwordHash_lte?: String;
  passwordHash_gt?: String;
  passwordHash_gte?: String;
  passwordHash_contains?: String;
  passwordHash_not_contains?: String;
  passwordHash_starts_with?: String;
  passwordHash_not_starts_with?: String;
  passwordHash_ends_with?: String;
  passwordHash_not_ends_with?: String;
  googleId?: String;
  googleId_not?: String;
  googleId_in?: String[] | String;
  googleId_not_in?: String[] | String;
  googleId_lt?: String;
  googleId_lte?: String;
  googleId_gt?: String;
  googleId_gte?: String;
  googleId_contains?: String;
  googleId_not_contains?: String;
  googleId_starts_with?: String;
  googleId_not_starts_with?: String;
  googleId_ends_with?: String;
  googleId_not_ends_with?: String;
  facebookId?: String;
  facebookId_not?: String;
  facebookId_in?: String[] | String;
  facebookId_not_in?: String[] | String;
  facebookId_lt?: String;
  facebookId_lte?: String;
  facebookId_gt?: String;
  facebookId_gte?: String;
  facebookId_contains?: String;
  facebookId_not_contains?: String;
  facebookId_starts_with?: String;
  facebookId_not_starts_with?: String;
  facebookId_ends_with?: String;
  facebookId_not_ends_with?: String;
  decks_every?: DeckWhereInput;
  decks_some?: DeckWhereInput;
  decks_none?: DeckWhereInput;
  ownerOfRoom_every?: RoomWhereInput;
  ownerOfRoom_some?: RoomWhereInput;
  ownerOfRoom_none?: RoomWhereInput;
  occupyingRoom_every?: RoomWhereInput;
  occupyingRoom_some?: RoomWhereInput;
  occupyingRoom_none?: RoomWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface RoomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  owner?: UserWhereInput;
  occupants_every?: UserWhereInput;
  occupants_some?: UserWhereInput;
  occupants_none?: UserWhereInput;
  messages_every?: SimpleUserRoomMessageWhereInput;
  messages_some?: SimpleUserRoomMessageWhereInput;
  messages_none?: SimpleUserRoomMessageWhereInput;
  active?: Boolean;
  active_not?: Boolean;
  AND?: RoomWhereInput[] | RoomWhereInput;
  OR?: RoomWhereInput[] | RoomWhereInput;
  NOT?: RoomWhereInput[] | RoomWhereInput;
}

export interface SimpleUserRoomMessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  room?: RoomWhereInput;
  sender?: UserWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: SimpleUserRoomMessageWhereInput[] | SimpleUserRoomMessageWhereInput;
  OR?: SimpleUserRoomMessageWhereInput[] | SimpleUserRoomMessageWhereInput;
  NOT?: SimpleUserRoomMessageWhereInput[] | SimpleUserRoomMessageWhereInput;
}

export interface SimpleCardWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  deck?: DeckWhereInput;
  front?: String;
  front_not?: String;
  front_in?: String[] | String;
  front_not_in?: String[] | String;
  front_lt?: String;
  front_lte?: String;
  front_gt?: String;
  front_gte?: String;
  front_contains?: String;
  front_not_contains?: String;
  front_starts_with?: String;
  front_not_starts_with?: String;
  front_ends_with?: String;
  front_not_ends_with?: String;
  back?: String;
  back_not?: String;
  back_in?: String[] | String;
  back_not_in?: String[] | String;
  back_lt?: String;
  back_lte?: String;
  back_gt?: String;
  back_gte?: String;
  back_contains?: String;
  back_not_contains?: String;
  back_starts_with?: String;
  back_not_starts_with?: String;
  back_ends_with?: String;
  back_not_ends_with?: String;
  AND?: SimpleCardWhereInput[] | SimpleCardWhereInput;
  OR?: SimpleCardWhereInput[] | SimpleCardWhereInput;
  NOT?: SimpleCardWhereInput[] | SimpleCardWhereInput;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SimpleCardWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SimpleUserRoomMessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface DeckCreateInput {
  name: String;
  owner: UserCreateOneWithoutDecksInput;
  cards?: SimpleCardCreateManyWithoutDeckInput;
  published?: Boolean;
}

export interface UserCreateOneWithoutDecksInput {
  create?: UserCreateWithoutDecksInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutDecksInput {
  email: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  defaultRoles?: UserCreatedefaultRolesInput;
  ownerOfRoom?: RoomCreateManyWithoutOwnerInput;
  occupyingRoom?: RoomCreateManyWithoutOccupantsInput;
}

export interface UserCreatedefaultRolesInput {
  set?: String[] | String;
}

export interface RoomCreateManyWithoutOwnerInput {
  create?: RoomCreateWithoutOwnerInput[] | RoomCreateWithoutOwnerInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
}

export interface RoomCreateWithoutOwnerInput {
  name: String;
  occupants?: UserCreateManyWithoutOccupyingRoomInput;
  messages?: SimpleUserRoomMessageCreateManyWithoutRoomInput;
  active: Boolean;
}

export interface UserCreateManyWithoutOccupyingRoomInput {
  create?:
    | UserCreateWithoutOccupyingRoomInput[]
    | UserCreateWithoutOccupyingRoomInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutOccupyingRoomInput {
  email: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckCreateManyWithoutOwnerInput;
  defaultRoles?: UserCreatedefaultRolesInput;
  ownerOfRoom?: RoomCreateManyWithoutOwnerInput;
}

export interface DeckCreateManyWithoutOwnerInput {
  create?: DeckCreateWithoutOwnerInput[] | DeckCreateWithoutOwnerInput;
  connect?: DeckWhereUniqueInput[] | DeckWhereUniqueInput;
}

export interface DeckCreateWithoutOwnerInput {
  name: String;
  cards?: SimpleCardCreateManyWithoutDeckInput;
  published?: Boolean;
}

export interface SimpleCardCreateManyWithoutDeckInput {
  create?:
    | SimpleCardCreateWithoutDeckInput[]
    | SimpleCardCreateWithoutDeckInput;
  connect?: SimpleCardWhereUniqueInput[] | SimpleCardWhereUniqueInput;
}

export interface SimpleCardCreateWithoutDeckInput {
  front: String;
  back: String;
}

export interface SimpleUserRoomMessageCreateManyWithoutRoomInput {
  create?:
    | SimpleUserRoomMessageCreateWithoutRoomInput[]
    | SimpleUserRoomMessageCreateWithoutRoomInput;
  connect?:
    | SimpleUserRoomMessageWhereUniqueInput[]
    | SimpleUserRoomMessageWhereUniqueInput;
}

export interface SimpleUserRoomMessageCreateWithoutRoomInput {
  sender: UserCreateOneInput;
  content: String;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  email: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckCreateManyWithoutOwnerInput;
  defaultRoles?: UserCreatedefaultRolesInput;
  ownerOfRoom?: RoomCreateManyWithoutOwnerInput;
  occupyingRoom?: RoomCreateManyWithoutOccupantsInput;
}

export interface RoomCreateManyWithoutOccupantsInput {
  create?: RoomCreateWithoutOccupantsInput[] | RoomCreateWithoutOccupantsInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
}

export interface RoomCreateWithoutOccupantsInput {
  name: String;
  owner: UserCreateOneWithoutOwnerOfRoomInput;
  messages?: SimpleUserRoomMessageCreateManyWithoutRoomInput;
  active: Boolean;
}

export interface UserCreateOneWithoutOwnerOfRoomInput {
  create?: UserCreateWithoutOwnerOfRoomInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutOwnerOfRoomInput {
  email: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckCreateManyWithoutOwnerInput;
  defaultRoles?: UserCreatedefaultRolesInput;
  occupyingRoom?: RoomCreateManyWithoutOccupantsInput;
}

export interface DeckUpdateInput {
  name?: String;
  owner?: UserUpdateOneRequiredWithoutDecksInput;
  cards?: SimpleCardUpdateManyWithoutDeckInput;
  published?: Boolean;
}

export interface UserUpdateOneRequiredWithoutDecksInput {
  create?: UserCreateWithoutDecksInput;
  update?: UserUpdateWithoutDecksDataInput;
  upsert?: UserUpsertWithoutDecksInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutDecksDataInput {
  email?: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  defaultRoles?: UserUpdatedefaultRolesInput;
  ownerOfRoom?: RoomUpdateManyWithoutOwnerInput;
  occupyingRoom?: RoomUpdateManyWithoutOccupantsInput;
}

export interface UserUpdatedefaultRolesInput {
  set?: String[] | String;
}

export interface RoomUpdateManyWithoutOwnerInput {
  create?: RoomCreateWithoutOwnerInput[] | RoomCreateWithoutOwnerInput;
  delete?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  disconnect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  update?:
    | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    | RoomUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    | RoomUpsertWithWhereUniqueWithoutOwnerInput;
}

export interface RoomUpdateWithWhereUniqueWithoutOwnerInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateWithoutOwnerDataInput;
}

export interface RoomUpdateWithoutOwnerDataInput {
  name?: String;
  occupants?: UserUpdateManyWithoutOccupyingRoomInput;
  messages?: SimpleUserRoomMessageUpdateManyWithoutRoomInput;
  active?: Boolean;
}

export interface UserUpdateManyWithoutOccupyingRoomInput {
  create?:
    | UserCreateWithoutOccupyingRoomInput[]
    | UserCreateWithoutOccupyingRoomInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutOccupyingRoomInput[]
    | UserUpdateWithWhereUniqueWithoutOccupyingRoomInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutOccupyingRoomInput[]
    | UserUpsertWithWhereUniqueWithoutOccupyingRoomInput;
}

export interface UserUpdateWithWhereUniqueWithoutOccupyingRoomInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutOccupyingRoomDataInput;
}

export interface UserUpdateWithoutOccupyingRoomDataInput {
  email?: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckUpdateManyWithoutOwnerInput;
  defaultRoles?: UserUpdatedefaultRolesInput;
  ownerOfRoom?: RoomUpdateManyWithoutOwnerInput;
}

export interface DeckUpdateManyWithoutOwnerInput {
  create?: DeckCreateWithoutOwnerInput[] | DeckCreateWithoutOwnerInput;
  delete?: DeckWhereUniqueInput[] | DeckWhereUniqueInput;
  connect?: DeckWhereUniqueInput[] | DeckWhereUniqueInput;
  disconnect?: DeckWhereUniqueInput[] | DeckWhereUniqueInput;
  update?:
    | DeckUpdateWithWhereUniqueWithoutOwnerInput[]
    | DeckUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | DeckUpsertWithWhereUniqueWithoutOwnerInput[]
    | DeckUpsertWithWhereUniqueWithoutOwnerInput;
}

export interface DeckUpdateWithWhereUniqueWithoutOwnerInput {
  where: DeckWhereUniqueInput;
  data: DeckUpdateWithoutOwnerDataInput;
}

export interface DeckUpdateWithoutOwnerDataInput {
  name?: String;
  cards?: SimpleCardUpdateManyWithoutDeckInput;
  published?: Boolean;
}

export interface SimpleCardUpdateManyWithoutDeckInput {
  create?:
    | SimpleCardCreateWithoutDeckInput[]
    | SimpleCardCreateWithoutDeckInput;
  delete?: SimpleCardWhereUniqueInput[] | SimpleCardWhereUniqueInput;
  connect?: SimpleCardWhereUniqueInput[] | SimpleCardWhereUniqueInput;
  disconnect?: SimpleCardWhereUniqueInput[] | SimpleCardWhereUniqueInput;
  update?:
    | SimpleCardUpdateWithWhereUniqueWithoutDeckInput[]
    | SimpleCardUpdateWithWhereUniqueWithoutDeckInput;
  upsert?:
    | SimpleCardUpsertWithWhereUniqueWithoutDeckInput[]
    | SimpleCardUpsertWithWhereUniqueWithoutDeckInput;
}

export interface SimpleCardUpdateWithWhereUniqueWithoutDeckInput {
  where: SimpleCardWhereUniqueInput;
  data: SimpleCardUpdateWithoutDeckDataInput;
}

export interface SimpleCardUpdateWithoutDeckDataInput {
  front?: String;
  back?: String;
}

export interface SimpleCardUpsertWithWhereUniqueWithoutDeckInput {
  where: SimpleCardWhereUniqueInput;
  update: SimpleCardUpdateWithoutDeckDataInput;
  create: SimpleCardCreateWithoutDeckInput;
}

export interface DeckUpsertWithWhereUniqueWithoutOwnerInput {
  where: DeckWhereUniqueInput;
  update: DeckUpdateWithoutOwnerDataInput;
  create: DeckCreateWithoutOwnerInput;
}

export interface UserUpsertWithWhereUniqueWithoutOccupyingRoomInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutOccupyingRoomDataInput;
  create: UserCreateWithoutOccupyingRoomInput;
}

export interface SimpleUserRoomMessageUpdateManyWithoutRoomInput {
  create?:
    | SimpleUserRoomMessageCreateWithoutRoomInput[]
    | SimpleUserRoomMessageCreateWithoutRoomInput;
  delete?:
    | SimpleUserRoomMessageWhereUniqueInput[]
    | SimpleUserRoomMessageWhereUniqueInput;
  connect?:
    | SimpleUserRoomMessageWhereUniqueInput[]
    | SimpleUserRoomMessageWhereUniqueInput;
  disconnect?:
    | SimpleUserRoomMessageWhereUniqueInput[]
    | SimpleUserRoomMessageWhereUniqueInput;
  update?:
    | SimpleUserRoomMessageUpdateWithWhereUniqueWithoutRoomInput[]
    | SimpleUserRoomMessageUpdateWithWhereUniqueWithoutRoomInput;
  upsert?:
    | SimpleUserRoomMessageUpsertWithWhereUniqueWithoutRoomInput[]
    | SimpleUserRoomMessageUpsertWithWhereUniqueWithoutRoomInput;
}

export interface SimpleUserRoomMessageUpdateWithWhereUniqueWithoutRoomInput {
  where: SimpleUserRoomMessageWhereUniqueInput;
  data: SimpleUserRoomMessageUpdateWithoutRoomDataInput;
}

export interface SimpleUserRoomMessageUpdateWithoutRoomDataInput {
  sender?: UserUpdateOneRequiredInput;
  content?: String;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  email?: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckUpdateManyWithoutOwnerInput;
  defaultRoles?: UserUpdatedefaultRolesInput;
  ownerOfRoom?: RoomUpdateManyWithoutOwnerInput;
  occupyingRoom?: RoomUpdateManyWithoutOccupantsInput;
}

export interface RoomUpdateManyWithoutOccupantsInput {
  create?: RoomCreateWithoutOccupantsInput[] | RoomCreateWithoutOccupantsInput;
  delete?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  disconnect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  update?:
    | RoomUpdateWithWhereUniqueWithoutOccupantsInput[]
    | RoomUpdateWithWhereUniqueWithoutOccupantsInput;
  upsert?:
    | RoomUpsertWithWhereUniqueWithoutOccupantsInput[]
    | RoomUpsertWithWhereUniqueWithoutOccupantsInput;
}

export interface RoomUpdateWithWhereUniqueWithoutOccupantsInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateWithoutOccupantsDataInput;
}

export interface RoomUpdateWithoutOccupantsDataInput {
  name?: String;
  owner?: UserUpdateOneRequiredWithoutOwnerOfRoomInput;
  messages?: SimpleUserRoomMessageUpdateManyWithoutRoomInput;
  active?: Boolean;
}

export interface UserUpdateOneRequiredWithoutOwnerOfRoomInput {
  create?: UserCreateWithoutOwnerOfRoomInput;
  update?: UserUpdateWithoutOwnerOfRoomDataInput;
  upsert?: UserUpsertWithoutOwnerOfRoomInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutOwnerOfRoomDataInput {
  email?: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckUpdateManyWithoutOwnerInput;
  defaultRoles?: UserUpdatedefaultRolesInput;
  occupyingRoom?: RoomUpdateManyWithoutOccupantsInput;
}

export interface UserUpsertWithoutOwnerOfRoomInput {
  update: UserUpdateWithoutOwnerOfRoomDataInput;
  create: UserCreateWithoutOwnerOfRoomInput;
}

export interface RoomUpsertWithWhereUniqueWithoutOccupantsInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateWithoutOccupantsDataInput;
  create: RoomCreateWithoutOccupantsInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SimpleUserRoomMessageUpsertWithWhereUniqueWithoutRoomInput {
  where: SimpleUserRoomMessageWhereUniqueInput;
  update: SimpleUserRoomMessageUpdateWithoutRoomDataInput;
  create: SimpleUserRoomMessageCreateWithoutRoomInput;
}

export interface RoomUpsertWithWhereUniqueWithoutOwnerInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateWithoutOwnerDataInput;
  create: RoomCreateWithoutOwnerInput;
}

export interface UserUpsertWithoutDecksInput {
  update: UserUpdateWithoutDecksDataInput;
  create: UserCreateWithoutDecksInput;
}

export interface DeckUpdateManyMutationInput {
  name?: String;
  published?: Boolean;
}

export interface RoomCreateInput {
  name: String;
  owner: UserCreateOneWithoutOwnerOfRoomInput;
  occupants?: UserCreateManyWithoutOccupyingRoomInput;
  messages?: SimpleUserRoomMessageCreateManyWithoutRoomInput;
  active: Boolean;
}

export interface RoomUpdateInput {
  name?: String;
  owner?: UserUpdateOneRequiredWithoutOwnerOfRoomInput;
  occupants?: UserUpdateManyWithoutOccupyingRoomInput;
  messages?: SimpleUserRoomMessageUpdateManyWithoutRoomInput;
  active?: Boolean;
}

export interface RoomUpdateManyMutationInput {
  name?: String;
  active?: Boolean;
}

export interface SimpleCardCreateInput {
  deck: DeckCreateOneWithoutCardsInput;
  front: String;
  back: String;
}

export interface DeckCreateOneWithoutCardsInput {
  create?: DeckCreateWithoutCardsInput;
  connect?: DeckWhereUniqueInput;
}

export interface DeckCreateWithoutCardsInput {
  name: String;
  owner: UserCreateOneWithoutDecksInput;
  published?: Boolean;
}

export interface SimpleCardUpdateInput {
  deck?: DeckUpdateOneRequiredWithoutCardsInput;
  front?: String;
  back?: String;
}

export interface DeckUpdateOneRequiredWithoutCardsInput {
  create?: DeckCreateWithoutCardsInput;
  update?: DeckUpdateWithoutCardsDataInput;
  upsert?: DeckUpsertWithoutCardsInput;
  connect?: DeckWhereUniqueInput;
}

export interface DeckUpdateWithoutCardsDataInput {
  name?: String;
  owner?: UserUpdateOneRequiredWithoutDecksInput;
  published?: Boolean;
}

export interface DeckUpsertWithoutCardsInput {
  update: DeckUpdateWithoutCardsDataInput;
  create: DeckCreateWithoutCardsInput;
}

export interface SimpleCardUpdateManyMutationInput {
  front?: String;
  back?: String;
}

export interface SimpleUserRoomMessageCreateInput {
  room: RoomCreateOneWithoutMessagesInput;
  sender: UserCreateOneInput;
  content: String;
}

export interface RoomCreateOneWithoutMessagesInput {
  create?: RoomCreateWithoutMessagesInput;
  connect?: RoomWhereUniqueInput;
}

export interface RoomCreateWithoutMessagesInput {
  name: String;
  owner: UserCreateOneWithoutOwnerOfRoomInput;
  occupants?: UserCreateManyWithoutOccupyingRoomInput;
  active: Boolean;
}

export interface SimpleUserRoomMessageUpdateInput {
  room?: RoomUpdateOneRequiredWithoutMessagesInput;
  sender?: UserUpdateOneRequiredInput;
  content?: String;
}

export interface RoomUpdateOneRequiredWithoutMessagesInput {
  create?: RoomCreateWithoutMessagesInput;
  update?: RoomUpdateWithoutMessagesDataInput;
  upsert?: RoomUpsertWithoutMessagesInput;
  connect?: RoomWhereUniqueInput;
}

export interface RoomUpdateWithoutMessagesDataInput {
  name?: String;
  owner?: UserUpdateOneRequiredWithoutOwnerOfRoomInput;
  occupants?: UserUpdateManyWithoutOccupyingRoomInput;
  active?: Boolean;
}

export interface RoomUpsertWithoutMessagesInput {
  update: RoomUpdateWithoutMessagesDataInput;
  create: RoomCreateWithoutMessagesInput;
}

export interface SimpleUserRoomMessageUpdateManyMutationInput {
  content?: String;
}

export interface UserUpdateInput {
  email?: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  decks?: DeckUpdateManyWithoutOwnerInput;
  defaultRoles?: UserUpdatedefaultRolesInput;
  ownerOfRoom?: RoomUpdateManyWithoutOwnerInput;
  occupyingRoom?: RoomUpdateManyWithoutOccupantsInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  defaultRoles?: UserUpdatedefaultRolesInput;
}

export interface DeckSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DeckWhereInput;
  AND?: DeckSubscriptionWhereInput[] | DeckSubscriptionWhereInput;
  OR?: DeckSubscriptionWhereInput[] | DeckSubscriptionWhereInput;
  NOT?: DeckSubscriptionWhereInput[] | DeckSubscriptionWhereInput;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoomWhereInput;
  AND?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  OR?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  NOT?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
}

export interface SimpleCardSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SimpleCardWhereInput;
  AND?: SimpleCardSubscriptionWhereInput[] | SimpleCardSubscriptionWhereInput;
  OR?: SimpleCardSubscriptionWhereInput[] | SimpleCardSubscriptionWhereInput;
  NOT?: SimpleCardSubscriptionWhereInput[] | SimpleCardSubscriptionWhereInput;
}

export interface SimpleUserRoomMessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SimpleUserRoomMessageWhereInput;
  AND?:
    | SimpleUserRoomMessageSubscriptionWhereInput[]
    | SimpleUserRoomMessageSubscriptionWhereInput;
  OR?:
    | SimpleUserRoomMessageSubscriptionWhereInput[]
    | SimpleUserRoomMessageSubscriptionWhereInput;
  NOT?:
    | SimpleUserRoomMessageSubscriptionWhereInput[]
    | SimpleUserRoomMessageSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Deck {
  id: ID_Output;
  name: String;
  published: Boolean;
}

export interface DeckPromise extends Promise<Deck>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  cards: <T = FragmentableArray<SimpleCard>>(
    args?: {
      where?: SimpleCardWhereInput;
      orderBy?: SimpleCardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  published: () => Promise<Boolean>;
}

export interface DeckSubscription
  extends Promise<AsyncIterator<Deck>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  cards: <T = Promise<AsyncIterator<SimpleCardSubscription>>>(
    args?: {
      where?: SimpleCardWhereInput;
      orderBy?: SimpleCardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  published: () => Promise<AsyncIterator<Boolean>>;
}

export interface User {
  id: ID_Output;
  email: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  defaultRoles: String[];
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  passwordHash: () => Promise<String>;
  googleId: () => Promise<String>;
  facebookId: () => Promise<String>;
  decks: <T = FragmentableArray<Deck>>(
    args?: {
      where?: DeckWhereInput;
      orderBy?: DeckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  defaultRoles: () => Promise<String[]>;
  ownerOfRoom: <T = FragmentableArray<Room>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  occupyingRoom: <T = FragmentableArray<Room>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  passwordHash: () => Promise<AsyncIterator<String>>;
  googleId: () => Promise<AsyncIterator<String>>;
  facebookId: () => Promise<AsyncIterator<String>>;
  decks: <T = Promise<AsyncIterator<DeckSubscription>>>(
    args?: {
      where?: DeckWhereInput;
      orderBy?: DeckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  defaultRoles: () => Promise<AsyncIterator<String[]>>;
  ownerOfRoom: <T = Promise<AsyncIterator<RoomSubscription>>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  occupyingRoom: <T = Promise<AsyncIterator<RoomSubscription>>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Room {
  id: ID_Output;
  name: String;
  active: Boolean;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  occupants: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  messages: <T = FragmentableArray<SimpleUserRoomMessage>>(
    args?: {
      where?: SimpleUserRoomMessageWhereInput;
      orderBy?: SimpleUserRoomMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  active: () => Promise<Boolean>;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  occupants: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  messages: <T = Promise<AsyncIterator<SimpleUserRoomMessageSubscription>>>(
    args?: {
      where?: SimpleUserRoomMessageWhereInput;
      orderBy?: SimpleUserRoomMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface SimpleUserRoomMessage {
  id: ID_Output;
  content: String;
}

export interface SimpleUserRoomMessagePromise
  extends Promise<SimpleUserRoomMessage>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  room: <T = RoomPromise>() => T;
  sender: <T = UserPromise>() => T;
  content: () => Promise<String>;
}

export interface SimpleUserRoomMessageSubscription
  extends Promise<AsyncIterator<SimpleUserRoomMessage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  room: <T = RoomSubscription>() => T;
  sender: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
}

export interface SimpleCard {
  id: ID_Output;
  front: String;
  back: String;
}

export interface SimpleCardPromise extends Promise<SimpleCard>, Fragmentable {
  id: () => Promise<ID_Output>;
  deck: <T = DeckPromise>() => T;
  front: () => Promise<String>;
  back: () => Promise<String>;
}

export interface SimpleCardSubscription
  extends Promise<AsyncIterator<SimpleCard>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deck: <T = DeckSubscription>() => T;
  front: () => Promise<AsyncIterator<String>>;
  back: () => Promise<AsyncIterator<String>>;
}

export interface DeckConnection {}

export interface DeckConnectionPromise
  extends Promise<DeckConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeckEdge>>() => T;
  aggregate: <T = AggregateDeckPromise>() => T;
}

export interface DeckConnectionSubscription
  extends Promise<AsyncIterator<DeckConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeckEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeckSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DeckEdge {
  cursor: String;
}

export interface DeckEdgePromise extends Promise<DeckEdge>, Fragmentable {
  node: <T = DeckPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeckEdgeSubscription
  extends Promise<AsyncIterator<DeckEdge>>,
    Fragmentable {
  node: <T = DeckSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDeck {
  count: Int;
}

export interface AggregateDeckPromise
  extends Promise<AggregateDeck>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeckSubscription
  extends Promise<AsyncIterator<AggregateDeck>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SimpleCardConnection {}

export interface SimpleCardConnectionPromise
  extends Promise<SimpleCardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SimpleCardEdge>>() => T;
  aggregate: <T = AggregateSimpleCardPromise>() => T;
}

export interface SimpleCardConnectionSubscription
  extends Promise<AsyncIterator<SimpleCardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SimpleCardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSimpleCardSubscription>() => T;
}

export interface SimpleCardEdge {
  cursor: String;
}

export interface SimpleCardEdgePromise
  extends Promise<SimpleCardEdge>,
    Fragmentable {
  node: <T = SimpleCardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SimpleCardEdgeSubscription
  extends Promise<AsyncIterator<SimpleCardEdge>>,
    Fragmentable {
  node: <T = SimpleCardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSimpleCard {
  count: Int;
}

export interface AggregateSimpleCardPromise
  extends Promise<AggregateSimpleCard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSimpleCardSubscription
  extends Promise<AsyncIterator<AggregateSimpleCard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SimpleUserRoomMessageConnection {}

export interface SimpleUserRoomMessageConnectionPromise
  extends Promise<SimpleUserRoomMessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SimpleUserRoomMessageEdge>>() => T;
  aggregate: <T = AggregateSimpleUserRoomMessagePromise>() => T;
}

export interface SimpleUserRoomMessageConnectionSubscription
  extends Promise<AsyncIterator<SimpleUserRoomMessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SimpleUserRoomMessageEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSimpleUserRoomMessageSubscription>() => T;
}

export interface SimpleUserRoomMessageEdge {
  cursor: String;
}

export interface SimpleUserRoomMessageEdgePromise
  extends Promise<SimpleUserRoomMessageEdge>,
    Fragmentable {
  node: <T = SimpleUserRoomMessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SimpleUserRoomMessageEdgeSubscription
  extends Promise<AsyncIterator<SimpleUserRoomMessageEdge>>,
    Fragmentable {
  node: <T = SimpleUserRoomMessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSimpleUserRoomMessage {
  count: Int;
}

export interface AggregateSimpleUserRoomMessagePromise
  extends Promise<AggregateSimpleUserRoomMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSimpleUserRoomMessageSubscription
  extends Promise<AsyncIterator<AggregateSimpleUserRoomMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DeckSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DeckSubscriptionPayloadPromise
  extends Promise<DeckSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DeckPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DeckPreviousValuesPromise>() => T;
}

export interface DeckSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeckSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeckSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DeckPreviousValuesSubscription>() => T;
}

export interface DeckPreviousValues {
  id: ID_Output;
  name: String;
  published: Boolean;
}

export interface DeckPreviousValuesPromise
  extends Promise<DeckPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  published: () => Promise<Boolean>;
}

export interface DeckPreviousValuesSubscription
  extends Promise<AsyncIterator<DeckPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name: String;
  active: Boolean;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  active: () => Promise<Boolean>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface SimpleCardSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SimpleCardSubscriptionPayloadPromise
  extends Promise<SimpleCardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SimpleCardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SimpleCardPreviousValuesPromise>() => T;
}

export interface SimpleCardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SimpleCardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SimpleCardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SimpleCardPreviousValuesSubscription>() => T;
}

export interface SimpleCardPreviousValues {
  id: ID_Output;
  front: String;
  back: String;
}

export interface SimpleCardPreviousValuesPromise
  extends Promise<SimpleCardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  front: () => Promise<String>;
  back: () => Promise<String>;
}

export interface SimpleCardPreviousValuesSubscription
  extends Promise<AsyncIterator<SimpleCardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  front: () => Promise<AsyncIterator<String>>;
  back: () => Promise<AsyncIterator<String>>;
}

export interface SimpleUserRoomMessageSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SimpleUserRoomMessageSubscriptionPayloadPromise
  extends Promise<SimpleUserRoomMessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SimpleUserRoomMessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SimpleUserRoomMessagePreviousValuesPromise>() => T;
}

export interface SimpleUserRoomMessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SimpleUserRoomMessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SimpleUserRoomMessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SimpleUserRoomMessagePreviousValuesSubscription>() => T;
}

export interface SimpleUserRoomMessagePreviousValues {
  id: ID_Output;
  content: String;
}

export interface SimpleUserRoomMessagePreviousValuesPromise
  extends Promise<SimpleUserRoomMessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface SimpleUserRoomMessagePreviousValuesSubscription
  extends Promise<AsyncIterator<SimpleUserRoomMessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  passwordHash?: String;
  googleId?: String;
  facebookId?: String;
  defaultRoles: String[];
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  passwordHash: () => Promise<String>;
  googleId: () => Promise<String>;
  facebookId: () => Promise<String>;
  defaultRoles: () => Promise<String[]>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  passwordHash: () => Promise<AsyncIterator<String>>;
  googleId: () => Promise<AsyncIterator<String>>;
  facebookId: () => Promise<AsyncIterator<String>>;
  defaultRoles: () => Promise<AsyncIterator<String[]>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Deck",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "SimpleCard",
    embedded: false
  },
  {
    name: "SimpleUserRoomMessage",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
